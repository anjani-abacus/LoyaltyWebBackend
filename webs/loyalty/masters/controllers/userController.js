import softDelete from "@shared/common/softDelete.js";
import prisma from "@shared/dbConfig/database.js";
import buildPrismaFilters from '@shared/common/buildPrismaFilters.js';
export const createUser = async (req, res, next) => {
    try {
        const {
            login_type,
            user_type,
            designation_id,
            designation_name,
            name,
            email,
            contact_01,
            employee_id,
            date_of_birth,
            date_of_wedding,
            date_of_joining,
            weekly_off,
            state_name,
            district_name,
            city,
            pincode,
            address,
            working_state_name,
            working_district_name,
            
        } = req.body;
        const existingUser = await prisma.sfa_user.findFirst({
            where: {
                email,
                contact_01
            }
        });

        if (existingUser) {
            return res.status(400).json({
                success: false,
                message: "User already exists",
            });
        }
        const autogeneratedusername = `${name?.split(" ")[0]?.toLowerCase() ?? "user"}_${contact_01?.toString().slice(-4) ?? "0000"}`;
         
        const user = await prisma.sfa_user.create({
            data: {
                login_type,
                user_type,
                designation_id,
                designation_name,
                name,
                email,
                contact_01,
                employee_id,
                date_of_birth: date_of_birth ? new Date(date_of_birth) : null,
                date_of_wedding: date_of_wedding ? new Date(date_of_wedding) : null,
                date_of_joining: date_of_joining ? new Date(date_of_joining) : null,
                weekly_off,
                state_name,
                district_name,
                city,
                pincode,
                address,
                working_state_name,
                working_district_name,
                username: autogeneratedusername,
                password: `${name?.split(" ")[0]?.toLowerCase()}_${Date.now().toString().slice(-2) }`,
            },
        });

        res.status(200).json({
            success: true,
            message: "User created or updated successfully!",
            user,
        });

    } catch (error) {
        next(error);
    }
};

export const getAllUsers = async (req, res,next) => {
    const { page = 1, limit = 20, filters = {} } = req.body;
    const skip = (Number(page) - 1) * Number(limit);
    const take = Number(limit);
    try {
        const fieldTypes = {
            status: "boolean",
            date_created: "date",
            name: "string",
            email: "string",
            contact_01: "number",
            employee_id: "string",
            designation_name: "string",
            state_name: "string",
            district_name: "string",
            city: "string",
            pincode: "number",
            user_type: "string",
        };

        const where = buildPrismaFilters(filters, fieldTypes);
        const totalUsers = await prisma.sfa_user.findMany();
        const users = await prisma.sfa_user.findMany({ where ,
            skip,
            take,
            orderBy: { date_created: 'desc' }
        });

        if (!users.length) {
            return res.status(200).json({ success: false, message: "No users found" });
        }
        const totalActive = totalUsers.filter(u => u.status === true || u.status === 'true').length;
        const totalInactive = totalUsers.length - totalActive;
        return res.status(200).json({
            success: true,
            message: "Users fetched successfully!",
            count: totalUsers.length,
            totalActive,
            totalInactive,
            data: users,
        });
    } catch (error) {
        next(error)
    }
};
export const getUserById = async (req, res,next) => {
    try{
    const { id } = req.params;
    const result= await prisma.sfa_user.findUnique({ where: { id: Number(id) } })
    return res.status(201).json({message :"Successfully fetched!", date:result})
   }catch(err){
    next(err)
}
}
export const getLedgerBalanceInfluencer = async (req,res,next) => {
    try {
        const {id} = req.params;

        const Entry = await prisma.influencer_ledger.findMany({
            where: {
                influencer_id:Number(id)
            },
            orderBy: {
            date_created: 'desc',
            },
            select: {
                id: true,
                date_created: true,
                transaction_type_name: true,
                credit:true,
                debit:true,
                balance: true,
            },
        });
        const prevBal = await prisma.influencer_customer.findFirst({
            where: { id:Number(id) },
            select: { current_wallet_balnc: true },
        });

if (!prevBal || prevBal.current_wallet_balnc === null || prevBal.current_wallet_balnc === undefined) {
            return res.status(402).json({ message: "PREV BALANCE NOT FOUND!" })
        };
     return res.status(200).json({ CurrentWalletBalance:prevBal.current_wallet_balnc,ance:Entry });
    } catch (error) {
        next(error)
    }
};
export const addCurrentWalletBal = async (req,res,next) => {
    try {
        const {id}=req.params;
        const {current_wallet_balnc}=req.body;
        const prevBal = await prisma.influencer_customer.findFirst({
            where: { id:Number(id) },
            select: { current_wallet_balnc: true },
        });

if (!prevBal || prevBal.current_wallet_balnc === null || prevBal.current_wallet_balnc === undefined) {
            return res.status(402).json({ message: "PREV BALANCE NOT FOUND!" })
        };
        const updated = await prisma.influencer_customer.update({
            where: {
                id:Number(id)
            },
            data: {
                current_wallet_balnc: current_wallet_balnc + prevBal.current_wallet_balnc,
                last_wallet_update:new Date()
            }
        })

        return res.status(201).json({status:true,message:"Successfully Updated !",data:updated})

    } catch (error) {
        next(error)
    }
};

export const getAllScannedCouponById = async (req, res, next) => {
    const {id} = req.params;

    try {
        const scannedCoupon = await prisma.offer_coupon_scan.findMany({
            where: { scanned_by_id:Number(id), del: false}
        })
      
        return res.status(200).json({
            status: true,
            data:scannedCoupon
        })
    }
    catch (error) {
        console.error(error);
        next(error);
    }
}   

export const deleteUser = async (req, res,next) => {
    const { id } = req.params;

    try {
        if (!id) {
            return res.status(400).json({ error: "User ID is required" });
        }

        await softDelete('sfa_user', 'id', Number(id));

        res.status(200).json({ success: true, message: "User has been deleted" });
    } catch (err) {
        next(err);
    }
};

export const updateUser = async (req, res, next) => {
    try {
        const { id } = req.params;
        const {
            user_type,
            designation_id,
            designation_name,
            name,
            email,
            contact_01,
            employee_id,
            date_of_birth,
            date_of_wedding,
            date_of_joining,
            weekly_off,
            reporting_Manager,
            state_name,
            district_name,
            city,
            pincode,
            address,
            working_state_name,
            working_district_name
        } = req.body;
        const existingUser = await prisma.sfa_user.findUnique({
            where: { id: Number(id), del: false }
        });

        if (!existingUser) {
            return res.status(404).json({ success: false, message: "User not found" });
        }

        const updatedUser = await prisma.sfa_user.update({
            where: { id: parseInt(id) },
            data: {
                user_type,
                designation_id,
                designation_name,
                name,
                email,
                contact_01,
                employee_id,
                date_of_birth:new Date (date_of_birth),
                date_of_wedding:new Date (date_of_wedding),
                date_of_joining:new Date (date_of_joining),
                weekly_off,
                reporting_Manager,
                state_name,
                district_name,
                city,
                pincode,
                address,
                working_state_name,
                working_district_name
            },
        });

        res.status(200).json({ success: true, user: updatedUser });
    } catch (error) {
        next(error);
    }
};